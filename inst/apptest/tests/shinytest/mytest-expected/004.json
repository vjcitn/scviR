{
  "input": {
    "btnSend": 0,
    "curmod": "scvi",
    "lev2": "JaxNegativeBinomialMeanDisp",
    "topmods": "distributions"
  },
  "output": {
    "pickedmodule": {
      "html": "<div id=\"lev2\" class=\"form-group shiny-input-radiogroup shiny-input-container shiny-input-container-inline\" role=\"radiogroup\" aria-labelledby=\"lev2-label\">\n  <label class=\"control-label\" id=\"lev2-label\" for=\"lev2\">subtop<\/label>\n  <div class=\"shiny-options-group\">\n    <label class=\"radio-inline\">\n      <input type=\"radio\" name=\"lev2\" value=\"JaxNegativeBinomialMeanDisp\" checked=\"checked\"/>\n      <span>JaxNegativeBinomialMeanDisp<\/span>\n    <\/label>\n    <label class=\"radio-inline\">\n      <input type=\"radio\" name=\"lev2\" value=\"NegativeBinomial\"/>\n      <span>NegativeBinomial<\/span>\n    <\/label>\n    <label class=\"radio-inline\">\n      <input type=\"radio\" name=\"lev2\" value=\"NegativeBinomialMixture\"/>\n      <span>NegativeBinomialMixture<\/span>\n    <\/label>\n    <label class=\"radio-inline\">\n      <input type=\"radio\" name=\"lev2\" value=\"Poisson\"/>\n      <span>Poisson<\/span>\n    <\/label>\n    <label class=\"radio-inline\">\n      <input type=\"radio\" name=\"lev2\" value=\"ZeroInflatedNegativeBinomial\"/>\n      <span>ZeroInflatedNegativeBinomial<\/span>\n    <\/label>\n  <\/div>\n<\/div>",
      "deps": [

      ]
    },
    "subtext": "Help on class JaxNegativeBinomialMeanDisp in module scvi.distributions._negative_binomial:<br><br>class JaxNegativeBinomialMeanDisp(numpyro.distributions.conjugate.NegativeBinomial2)<br> |  JaxNegativeBinomialMeanDisp(mean: jax.Array, inverse_dispersion: jax.Array, validate_args: Union[bool, NoneType] = None, eps: float = 1e-08)<br> |  <br> |  Negative binomial parameterized by mean and inverse dispersion.<br> |  <br> |  Method resolution order:<br> |      JaxNegativeBinomialMeanDisp<br> |      numpyro.distributions.conjugate.NegativeBinomial2<br> |      numpyro.distributions.conjugate.GammaPoisson<br> |      numpyro.distributions.distribution.Distribution<br> |      builtins.object<br> |  <br> |  Methods defined here:<br> |  <br> |  __init__(self, mean: jax.Array, inverse_dispersion: jax.Array, validate_args: Union[bool, NoneType] = None, eps: float = 1e-08)<br> |      Initialize self.  See help(type(self)) for accurate signature.<br> |  <br> |  log_prob = wrapper(self, *args, **kwargs)<br> |  <br> |  ----------------------------------------------------------------------<br> |  Readonly properties defined here:<br> |  <br> |  inverse_dispersion<br> |  <br> |  mean<br> |      Mean of the distribution.<br> |  <br> |  ----------------------------------------------------------------------<br> |  Data and other attributes defined here:<br> |  <br> |  __signature__ = <Signature (mean: jax.Array, inverse_dispersion:...nio...<br> |  <br> |  arg_constraints = {'inverse_dispersion': Positive(lower_bound=0.0), 'm...<br> |  <br> |  support = IntegerNonnegative(lower_bound=0)<br> |  <br> |  <br> |  ----------------------------------------------------------------------<br> |  Methods inherited from numpyro.distributions.conjugate.GammaPoisson:<br> |  <br> |  cdf(self, value)<br> |      The cummulative distribution function of this distribution.<br> |      <br> |      :param value: samples from this distribution.<br> |      :return: output of the cummulative distribution function evaluated at `value`.<br> |  <br> |  sample(self, key, sample_shape=())<br> |      Returns a sample from the distribution having shape given by<br> |      `sample_shape + batch_shape + event_shape`. Note that when `sample_shape` is non-empty,<br> |      leading dimensions (of size `sample_shape`) of the returned sample will<br> |      be filled with iid draws from the distribution instance.<br> |      <br> |      :param jax.random.PRNGKey key: the rng_key key to be used for the distribution.<br> |      :param tuple sample_shape: the sample shape for the distribution.<br> |      :return: an array of shape `sample_shape + batch_shape + event_shape`<br> |      :rtype: numpy.ndarray<br> |  <br> |  ----------------------------------------------------------------------<br> |  Readonly properties inherited from numpyro.distributions.conjugate.GammaPoisson:<br> |  <br> |  variance<br> |      Variance of the distribution.<br> |  <br> |  ----------------------------------------------------------------------<br> |  Methods inherited from numpyro.distributions.distribution.Distribution:<br> |  <br> |  __call__(self, *args, **kwargs)<br> |      Call self as a function.<br> |  <br> |  enumerate_support(self, expand=True)<br> |      Returns an array with shape `len(support) x batch_shape`<br> |      containing all values in the support.<br> |  <br> |  expand(self, batch_shape)<br> |      Returns a new :class:`ExpandedDistribution` instance with batch<br> |      dimensions expanded to `batch_shape`.<br> |      <br> |      :param tuple batch_shape: batch shape to expand to.<br> |      :return: an instance of `ExpandedDistribution`.<br> |      :rtype: :class:`ExpandedDistribution`<br> |  <br> |  expand_by(self, sample_shape)<br> |      Expands a distribution by adding ``sample_shape`` to the left side of<br> |      its :attr:`~numpyro.distributions.distribution.Distribution.batch_shape`.<br> |      To expand internal dims of ``self.batch_shape`` from 1 to something<br> |      larger, use :meth:`expand` instead.<br> |      <br> |      :param tuple sample_shape: The size of the iid batch to be drawn<br> |          from the distribution.<br> |      :return: An expanded version of this distribution.<br> |      :rtype: :class:`ExpandedDistribution`<br> |  <br> |  icdf(self, q)<br> |      The inverse cumulative distribution function of this distribution.<br> |      <br> |      :param q: quantile values, should belong to [0, 1].<br> |      :return: the samples whose cdf values equals to `q`.<br> |  <br> |  mask(self, mask)<br> |      Masks a distribution by a boolean or boolean-valued array that is<br> |      broadcastable to the distributions<br> |      :attr:`Distribution.batch_shape` .<br> |      <br> |      :param mask: A boolean or boolean valued array (`True` includes<br> |          a site, `False` excludes a site).<br> |      :type mask: bool or jnp.ndarray<br> |      :return: A masked copy of this distribution.<br> |      :rtype: :class:`MaskedDistribution`<br> |      <br> |      **Example:**<br> |      <br> |      .. doctest::<br> |      <br> |          >>> from jax import random<br> |          >>> import jax.numpy as jnp<br> |          >>> import numpyro<br> |          >>> import numpyro.distributions as dist<br> |          >>> from numpyro.distributions import constraints<br> |          >>> from numpyro.infer import SVI, Trace_ELBO<br> |      <br> |          >>> def model(data, m):<br> |          ...     f = numpyro.sample(\"latent_fairness\", dist.Beta(1, 1))<br> |          ...     with numpyro.plate(\"N\", data.shape[0]):<br> |          ...         # only take into account the values selected by the mask<br> |          ...         masked_dist = dist.Bernoulli(f).mask(m)<br> |          ...         numpyro.sample(\"obs\", masked_dist, obs=data)<br> |      <br> |      <br> |          >>> def guide(data, m):<br> |          ...     alpha_q = numpyro.param(\"alpha_q\", 5., constraint=constraints.positive)<br> |          ...     beta_q = numpyro.param(\"beta_q\", 5., constraint=constraints.positive)<br> |          ...     numpyro.sample(\"latent_fairness\", dist.Beta(alpha_q, beta_q))<br> |      <br> |      <br> |          >>> data = jnp.concatenate([jnp.ones(5), jnp.zeros(5)])<br> |          >>> # select values equal to one<br> |          >>> masked_array = jnp.where(data == 1, True, False)<br> |          >>> optimizer = numpyro.optim.Adam(step_size=0.05)<br> |          >>> svi = SVI(model, guide, optimizer, loss=Trace_ELBO())<br> |          >>> svi_result = svi.run(random.PRNGKey(0), 300, data, masked_array)<br> |          >>> params = svi_result.params<br> |          >>> # inferred_mean is closer to 1<br> |          >>> inferred_mean = params[\"alpha_q\"] / (params[\"alpha_q\"] + params[\"beta_q\"])<br> |  <br> |  rsample(self, key, sample_shape=())<br> |  <br> |  sample_with_intermediates(self, key, sample_shape=())<br> |      Same as ``sample`` except that any intermediate computations are<br> |      returned (useful for `TransformedDistribution`).<br> |      <br> |      :param jax.random.PRNGKey key: the rng_key key to be used for the distribution.<br> |      :param tuple sample_shape: the sample shape for the distribution.<br> |      :return: an array of shape `sample_shape + batch_shape + event_shape`<br> |      :rtype: numpy.ndarray<br> |  <br> |  shape(self, sample_shape=())<br> |      The tensor shape of samples from this distribution.<br> |      <br> |      Samples are of shape::<br> |      <br> |          d.shape(sample_shape) == sample_shape + d.batch_shape + d.event_shape<br> |      <br> |      :param tuple sample_shape: the size of the iid batch to be drawn from the<br> |          distribution.<br> |      :return: shape of samples.<br> |      :rtype: tuple<br> |  <br> |  to_event(self, reinterpreted_batch_ndims=None)<br> |      Interpret the rightmost `reinterpreted_batch_ndims` batch dimensions as<br> |      dependent event dimensions.<br> |      <br> |      :param reinterpreted_batch_ndims: Number of rightmost batch dims to<br> |          interpret as event dims.<br> |      :return: An instance of `Independent` distribution.<br> |      :rtype: numpyro.distributions.distribution.Independent<br> |  <br> |  tree_flatten(self)<br> |  <br> |  ----------------------------------------------------------------------<br> |  Class methods inherited from numpyro.distributions.distribution.Distribution:<br> |  <br> |  __init_subclass__(**kwargs) from numpyro.distributions.distribution.DistributionMeta<br> |      This method is called when a class is subclassed.<br> |      <br> |      The default implementation does nothing. It may be<br> |      overridden to extend subclasses.<br> |  <br> |  infer_shapes(*args, **kwargs) from numpyro.distributions.distribution.DistributionMeta<br> |      Infers ``batch_shape`` and ``event_shape`` given shapes of args to<br> |      :meth:`__init__`.<br> |      <br> |      .. note:: This assumes distribution shape depends only on the shapes<br> |          of tensor inputs, not in the data contained in those inputs.<br> |      <br> |      :param \\*args: Positional args replacing each input arg with a<br> |          tuple representing the sizes of each tensor input.<br> |      :param \\*\\*kwargs: Keywords mapping name of input arg to tuple<br> |          representing the sizes of each tensor input.<br> |      :returns: A pair ``(batch_shape, event_shape)`` of the shapes of a<br> |          distribution that would be created with input args of the given<br> |          shapes.<br> |      :rtype: tuple<br> |  <br> |  tree_unflatten(aux_data, params) from numpyro.distributions.distribution.DistributionMeta<br> |  <br> |  ----------------------------------------------------------------------<br> |  Static methods inherited from numpyro.distributions.distribution.Distribution:<br> |  <br> |  set_default_validate_args(value)<br> |  <br> |  ----------------------------------------------------------------------<br> |  Readonly properties inherited from numpyro.distributions.distribution.Distribution:<br> |  <br> |  batch_shape<br> |      Returns the shape over which the distribution parameters are batched.<br> |      <br> |      :return: batch shape of the distribution.<br> |      :rtype: tuple<br> |  <br> |  event_dim<br> |      :return: Number of dimensions of individual events.<br> |      :rtype: int<br> |  <br> |  event_shape<br> |      Returns the shape of a single sample from the distribution without<br> |      batching.<br> |      <br> |      :return: event shape of the distribution.<br> |      :rtype: tuple<br> |  <br> |  has_rsample<br> |  <br> |  is_discrete<br> |  <br> |  ----------------------------------------------------------------------<br> |  Data descriptors inherited from numpyro.distributions.distribution.Distribution:<br> |  <br> |  __dict__<br> |      dictionary for instance variables (if defined)<br> |  <br> |  __weakref__<br> |      list of weak references to the object (if defined)<br> |  <br> |  ----------------------------------------------------------------------<br> |  Data and other attributes inherited from numpyro.distributions.distribution.Distribution:<br> |  <br> |  has_enumerate_support = False<br> |  <br> |  reparametrized_params = []<br><br><br>",
    "topmodules": {
      "html": "<div id=\"topmods\" class=\"form-group shiny-input-radiogroup shiny-input-container\" role=\"radiogroup\" aria-labelledby=\"topmods-label\">\n  <label class=\"control-label\" id=\"topmods-label\" for=\"topmods\">modules<\/label>\n  <div class=\"shiny-options-group\">\n    <div class=\"radio\">\n      <label>\n        <input type=\"radio\" name=\"topmods\" value=\"autotune\" checked=\"checked\"/>\n        <span>autotune<\/span>\n      <\/label>\n    <\/div>\n    <div class=\"radio\">\n      <label>\n        <input type=\"radio\" name=\"topmods\" value=\"data\"/>\n        <span>data<\/span>\n      <\/label>\n    <\/div>\n    <div class=\"radio\">\n      <label>\n        <input type=\"radio\" name=\"topmods\" value=\"dataloaders\"/>\n        <span>dataloaders<\/span>\n      <\/label>\n    <\/div>\n    <div class=\"radio\">\n      <label>\n        <input type=\"radio\" name=\"topmods\" value=\"distributions\"/>\n        <span>distributions<\/span>\n      <\/label>\n    <\/div>\n    <div class=\"radio\">\n      <label>\n        <input type=\"radio\" name=\"topmods\" value=\"external\"/>\n        <span>external<\/span>\n      <\/label>\n    <\/div>\n    <div class=\"radio\">\n      <label>\n        <input type=\"radio\" name=\"topmods\" value=\"logging\"/>\n        <span>logging<\/span>\n      <\/label>\n    <\/div>\n    <div class=\"radio\">\n      <label>\n        <input type=\"radio\" name=\"topmods\" value=\"model\"/>\n        <span>model<\/span>\n      <\/label>\n    <\/div>\n    <div class=\"radio\">\n      <label>\n        <input type=\"radio\" name=\"topmods\" value=\"module\"/>\n        <span>module<\/span>\n      <\/label>\n    <\/div>\n    <div class=\"radio\">\n      <label>\n        <input type=\"radio\" name=\"topmods\" value=\"nn\"/>\n        <span>nn<\/span>\n      <\/label>\n    <\/div>\n    <div class=\"radio\">\n      <label>\n        <input type=\"radio\" name=\"topmods\" value=\"train\"/>\n        <span>train<\/span>\n      <\/label>\n    <\/div>\n    <div class=\"radio\">\n      <label>\n        <input type=\"radio\" name=\"topmods\" value=\"utils\"/>\n        <span>utils<\/span>\n      <\/label>\n    <\/div>\n  <\/div>\n<\/div>",
      "deps": [

      ]
    }
  },
  "export": {

  }
}
